"""
msc_to_py.py - Mixo-Script to Python transpiler (v0.1.0)

This transpiler converts Mixo-Script (.msc) files to equivalent Python code.
"""

import sys


def msc_func_block_to_py(func_name, args):
    match func_name:
        case "read": return _read_to_py(args)
        case "create": return _create_to_py(args)
        case "map": return _map_to_py(args)
        case "write": return _write_to_py(args)
        case _: return f"# Unknown function block: {func_name}"

def _read_to_py(args):
    arg_dict = {}
    arg_dict["file_path"] = args[0]
    for arg in args[1:]:
        k = arg.split(" ")[0]
        v = " ".join(arg.split(" ")[1:])
        arg_dict[k] = v
    
    req = ["file_path", "as"]
    for r in req:
        assert r in arg_dict, f"Missing required argument: {r} for read block"
    
    defaults = {
        "split": None
    }

    if arg_dict["file_path"] == "io:stdin":
        _py_str = f"{arg_dict['as']} = input()"
        if arg_dict.get("split", defaults['split']) != None:
            _py_str += f".split({arg_dict['split']})"
    else:
        _py_str = f"with open({arg_dict['file_path']}, 'r', encoding='utf-8') as __MIXO_F__:\n\t{arg_dict['as']} = __MIXO_F__.read()"
        if arg_dict.get("split", defaults['split']) != None:
            _py_str += f".split({arg_dict['split']})"
    
    return _py_str

def _create_to_py(args):
    arg_dict = {}
    arg_dict["type"] = args[0]
    for arg in args[1:]:
        k = arg.split(" ")[0]
        v = " ".join(arg.split(" ")[1:])
        arg_dict[k] = v
    
    req = ["type", "as"]
    for r in req:
        assert r in arg_dict, f"Missing required argument: {r} for create block"
    
    _py_str = f"{arg_dict['as']} = {arg_dict['type']}()"
    return _py_str

def _map_to_py(args):
    arg_dict = {}
    arg_dict["from"] = args[0]
    for arg in args[1:]:
        k = arg.split(" ")[0]
        v = " ".join(arg.split(" ")[1:])
        if k == "op":
            if "ops" not in arg_dict:
                arg_dict["ops"] = []
            if "=>" in v:
                v = _arrow_func_to_lambda(v)
            arg_dict["ops"].append(v)
        else:
            arg_dict[k] = v
    
    req = ["from", "as", "to", "ops"]
    for r in req:
        assert r in arg_dict, f"Missing required argument: {r} for map block"
    
    _py_str = f"{arg_dict['to']} = list(map("
    _py_str += f"lambda {arg_dict['as']}: "
    
    # handle multiple operations correctly
    for op in arg_dict["ops"]:
        _py_str += f"__MIXO_OP_RESULT__({op}, "
    _py_str += f"{arg_dict['as']}"
    for _ in arg_dict["ops"]:
        _py_str += ")"
    
    _py_str += f", {arg_dict['from']}))"

    return _py_str
    

    

def _write_to_py(args):
    arg_dict = {}
    arg_dict["from"] = args[0]
    for arg in args[1:]:
        k = arg.split(" ")[0]
        v = " ".join(arg.split(" ")[1:])
        arg_dict[k] = v
    
    req = ["from", "to"]
    for r in req:
        assert r in arg_dict, f"Missing required argument: {r} for write block"
    
    if arg_dict["to"] == "io:stdout":
        _py_str = f"print({arg_dict['from']})"
    else:
        _py_str = f"with open({arg_dict['to']}, 'w', encoding='utf-8') as __MIXO_F__:\n\t__MIXO_F__.write("
        if arg_dict.get("join", None) != None:
            _py_str += f"{arg_dict['join']}.join(list(map(lambda x: str(x), {arg_dict['from']})))"
        else:
            _py_str += f"{arg_dict['from']}"
        _py_str += ")"

    
    return _py_str

def _arrow_func_to_lambda(arrow_func):
    # transform from (args) => {body} to lambda args: body
    args = arrow_func.split("=>")[0].strip()[1:-1]
    body = arrow_func.split("=>")[1].strip()[1:-1]
    return f"lambda {args}: {body}"


def _sanitize_py(py_str):
    py_str = py_str.replace("__MIXO_TAB__", "\\t")
    py_str = py_str.replace("__MIXO_NEWLINE__", "\\n")
    return py_str

def _add_framework():
    framework = """
# This file was generated by msc_to_py.py v0.1.0
# Mixo-Script to Python transpiler
def __MIXO_OP_RESULT__(func, val):
    return func(val)
toInt = lambda x: int(x)
toStr = lambda x: str(x)

"""
    return framework

def transpile(input_file_path, output_file_path):
    with open(input_file_path, "r", encoding="utf-8") as f:
        msc_file_contents = f.read()
    
    # sanitize \t and \n inside string literals
    output_str = ""
    is_in_string = False
    for c in msc_file_contents:
        if c == '"':
            is_in_string = not is_in_string
        if is_in_string:
            if c == "\t":
                c = "__MIXO_TAB__"
            elif c == "\n":
                c = "__MIXO_NEWLINE__"
        output_str += c
    msc_file_contents = output_str


    function_blocks = [] #(func_name, *args)

    current_func_block = []
    for line in msc_file_contents.split("\n"):
        if "//" in line:
            line = line.split("//")[0]
        
        if line.strip() == "":
            if current_func_block:
                function_blocks.append(current_func_block)
            current_func_block = []
        elif line.startswith("\t") or line.startswith("    "):
            current_func_block[1].append(line.strip())
        else:
            current_func_block = [line.strip(), []]
    
    output_py = _add_framework()
    for func_block in function_blocks:
        output_py += msc_func_block_to_py(func_block[0], func_block[1]) + "\n"
    
    output_py = _sanitize_py(output_py)

    with open(output_file_path, "w", encoding="utf-8") as f:
        f.write(output_py)

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python msc_to_py.py <input_file_path> <output_file_path>")
        sys.exit(1)
    
    input_file_path = sys.argv[1]
    output_file_path = sys.argv[2]

    transpile(input_file_path, output_file_path)
    print(f"Transpiled {input_file_path} to {output_file_path}")
    
